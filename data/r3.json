{
  "category" : "Front-End Developer",
  "tech-stack" : "ReactJS, NextJS, Redux, TypeScript, JavaScript, HTML, CSS",
  "prompt" : "This comprehensive guide outlines best practices, conventions, and standards for development with modern web technologies including ReactJS, NextJS, Redux, TypeScript, JavaScript, HTML, CSS, and UI frameworks.\n\n    Development Philosophy\n    - Write clean, maintainable, and scalable code\n    - Follow SOLID principles\n    - Prefer functional and declarative programming patterns over imperative\n    - Emphasize type safety and static analysis\n    - Practice component-driven development\n\n    Code Implementation Guidelines\n    Planning Phase\n    - Begin with step-by-step planning\n    - Write detailed pseudocode before implementation\n    - Document component architecture and data flow\n    - Consider edge cases and error scenarios\n\n    Code Style\n    - Use tabs for indentation\n    - Use single quotes for strings (except to avoid escaping)\n    - Omit semicolons (unless required for disambiguation)\n    - Eliminate unused variables\n    - Add space after keywords\n    - Add space before function declaration parentheses\n    - Always use strict equality (===) instead of loose equality (==)\n    - Space infix operators\n    - Add space after commas\n    - Keep else statements on the same line as closing curly braces\n    - Use curly braces for multi-line if statements\n    - Always handle error parameters in callbacks\n    - Limit line length to 80 characters\n    - Use trailing commas in multiline object/array literals\n\n    Naming Conventions\n    General Rules\n    - Use PascalCase for:\n      - Components\n      - Type definitions\n      - Interfaces\n    - Use kebab-case for:\n      - Directory names (e.g., components/auth-wizard)\n      - File names (e.g., user-profile.tsx)\n    - Use camelCase for:\n      - Variables\n      - Functions\n      - Methods\n      - Hooks\n      - Properties\n      - Props\n    - Use UPPERCASE for:\n      - Environment variables\n      - Constants\n      - Global configurations\n\n    Specific Naming Patterns\n    - Prefix event handlers with 'handle': handleClick, handleSubmit\n    - Prefix boolean variables with verbs: isLoading, hasError, canSubmit\n    - Prefix custom hooks with 'use': useAuth, useForm\n    - Use complete words over abbreviations except for:\n      - err (error)\n      - req (request)\n      - res (response)\n      - props (properties)\n      - ref (reference)\n\n    React Best Practices\n    Component Architecture\n    - Use functional components with TypeScript interfaces\n    - Define components using the function keyword\n    - Extract reusable logic into custom hooks\n    - Implement proper component composition\n    - Use React.memo() strategically for performance\n    - Implement proper cleanup in useEffect hooks\n\n    React Performance Optimization\n    - Use useCallback for memoizing callback functions\n    - Implement useMemo for expensive computations\n    - Avoid inline function definitions in JSX\n    - Implement code splitting using dynamic imports\n    - Implement proper key props in lists (avoid using index as key)\n\n    Next.js Best Practices\n    Core Concepts\n    - Utilize App Router for routing\n    - Implement proper metadata management\n    - Use proper caching strategies\n    - Implement proper error boundaries\n\n    Components and Features\n    - Use Next.js built-in components:\n      - Image component for optimized images\n      - Link component for client-side navigation\n      - Script component for external scripts\n      - Head component for metadata\n    - Implement proper loading states\n    - Use proper data fetching methods\n\n    Server Components\n    - Default to Server Components\n    - Use URL query parameters for data fetching and server state management\n    - Use 'use client' directive only when necessary:\n      - Event listeners\n      - Browser APIs\n      - State management\n      - Client-side-only libraries\n\n    TypeScript Implementation\n    - Enable strict mode\n    - Define clear interfaces for component props, state, and Redux state structure.\n    - Use type guards to handle potential undefined or null values safely.\n    - Apply generics to functions, actions, and slices where type flexibility is needed.\n    - Utilize TypeScript utility types (Partial, Pick, Omit) for cleaner and reusable code.\n    - Prefer interface over type for defining object structures, especially when extending.\n    - Use mapped types for creating variations of existing types dynamically.\n\n    UI and Styling\n    Component Libraries\n    - Use Shadcn UI for consistent, accessible component design.\n    - Integrate Radix UI primitives for customizable, accessible UI elements.\n    - Apply composition patterns to create modular, reusable components.\n\n    Styling Guidelines\n    - Use Tailwind CSS for styling\n    - Use Tailwind CSS for utility-first, maintainable styling.\n    - Design with mobile-first, responsive principles for flexibility across devices.\n    - Implement dark mode using CSS variables or Tailwindâ€™s dark mode features.\n    - Ensure color contrast ratios meet accessibility standards for readability.\n    - Maintain consistent spacing values to establish visual harmony.\n    - Define CSS variables for theme colors and spacing to support easy theming and maintainability.\n\n    State Management\n    Local State\n    - Use useState for component-level state\n    - Implement useReducer for complex state\n    - Use useContext for shared state\n    - Implement proper state initialization\n\n    Global State\n    - Use Redux Toolkit for global state\n    - Use createSlice to define state, reducers, and actions together.\n    - Avoid using createReducer and createAction unless necessary.\n    - Normalize state structure to avoid deeply nested data.\n    - Use selectors to encapsulate state access.\n    - Avoid large, all-encompassing slices; separate concerns by feature.\n\n\n    Error Handling and Validation\n    Form Validation\n    - Use Zod for schema validation\n    - Implement proper error messages\n    - Use proper form libraries (e.g., React Hook Form)\n\n    Error Boundaries\n    - Use error boundaries to catch and handle errors in React component trees gracefully.\n    - Log caught errors to an external service (e.g., Sentry) for tracking and debugging.\n    - Design user-friendly fallback UIs to display when errors occur, keeping users informed without breaking the app.\n\n    Testing\n    Unit Testing\n    - Write thorough unit tests to validate individual functions and components.\n    - Use Jest and React Testing Library for reliable and efficient testing of React components.\n    - Follow patterns like Arrange-Act-Assert to ensure clarity and consistency in tests.\n    - Mock external dependencies and API calls to isolate unit tests.\n\n    Integration Testing\n    - Focus on user workflows to ensure app functionality.\n    - Set up and tear down test environments properly to maintain test independence.\n    - Use snapshot testing selectively to catch unintended UI changes without over-relying on it.\n    - Leverage testing utilities (e.g., screen in RTL) for cleaner and more readable tests.\n\n    Accessibility (a11y)\n    Core Requirements\n    - Use semantic HTML for meaningful structure.\n    - Apply accurate ARIA attributes where needed.\n    - Ensure full keyboard navigation support.\n    - Manage focus order and visibility effectively.\n    - Maintain accessible color contrast ratios.\n    - Follow a logical heading hierarchy.\n    - Make all interactive elements accessible.\n    - Provide clear and accessible error feedback.\n\n    Security\n    - Implement input sanitization to prevent XSS attacks.\n    - Use DOMPurify for sanitizing HTML content.\n    - Use proper authentication methods.\n\n    Internationalization (i18n)\n    - Use next-i18next for translations\n    - Implement proper locale detection\n    - Use proper number and date formatting\n    - Implement proper RTL support\n    - Use proper currency formatting\n\n    Documentation\n    - Use JSDoc for documentation\n    - Document all public functions, classes, methods, and interfaces\n    - Add examples when appropriate\n    - Use complete sentences with proper punctuation\n    - Keep descriptions clear and concise\n    - Use proper markdown formatting\n    - Use proper code blocks\n    - Use proper links\n    - Use proper headings\n    - Use proper lists"
}